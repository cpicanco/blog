<!--Copyright (c) 2015-2016 Carlos Rafael Fernandes Picanço.-->
<!DOCTYPE html>
<html lang="pt-BR">


<!-- Head -->
  

  

  

  <head prefix="og: https://ogp.me/ns# fb: https://ogp.me/ns/fb# article: https://ogp.me/ns/article#">
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59877002-2"></script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-M3ZGK8V');</script>
    <!-- End Google Tag Manager -->    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Pensamentos sobre Introdução ao desenvolvimento de interfaces gráficas com Lazarus e Free Pascal, postado por Rafael Picanço, cientista do comportamento, programador entusiasta e baterista freelance.">
  
    <!-- Open Graph meta tags -->
    <meta property="og:title" content="In Flagellis. | Object Pascal e Análise do Comportamento">
    <meta property="og:type" content="article">
    <meta property="og:description" content="Pensamentos sobre Introdução ao desenvolvimento de interfaces gráficas com Lazarus e Free Pascal, postado por Rafael Picanço, cientista do comportamento, programador entusiasta e baterista freelance.">
    <meta property="og:url" content="https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html">
    <meta property="og:image" content="https://blog.rafael.picanco.nom.br/media/blog/in-flagellis-clean-pt-br.png">
    <meta property="og:image:width" content="613">
    <meta property="og:image:height" content="448">
  
    <meta property="og:locale" content="pt_BR">
  
    <meta property="og:site_name" content="In Flagellis.">
    <meta property="fb:profile_id" content="1651005333">
    <meta property="fb:app_id" content="302184056577324">

    <!-- Twitter Card properties -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="In Flagellis. | Object Pascal e Análise do Comportamento">
    <meta name="twitter:creator" content="@crpicanco">
    <meta name="twitter:description" content="Pensamentos sobre Introdução ao desenvolvimento de interfaces gráficas com Lazarus e Free Pascal, postado por Rafael Picanço, cientista do comportamento, programador entusiasta e baterista freelance.">
    <meta name="twitter:image" content="https://blog.rafael.picanco.nom.br/media/blog/in-flagellis-clean-pt-br.png">
    <meta name="twitter:image:width" content="613">
    <meta name="twitter:image:height" content="448">
    
    <title>In Flagellis. | Object Pascal e Análise do Comportamento</title>

    <link rel="image_src" href="https://blog.rafael.picanco.nom.br/media/blog/in-flagellis-clean-pt-br.png" >
    <link rel="canonical" href="https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html">
    <link rel="icon" href="/media/favicon.ico">
    <!-- Bootstrap core CSS -->
    <!-- Custom CSS -->
    <!-- Highlight.js --> 
    <link href="/css/blog-styles.concat.css" rel="stylesheet">
    <!-- Custom Fonts -->   
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
  </head>



  <body>
   <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M3ZGK8V"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
 
   <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            
              <span class="sr-only">Alternar navegação</span>
            
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>

          </button>
          
            <a class="navbar-brand" href="http://portfolio.rafael.picanco.nom.br/pt-br/projects.html">&middot;&#32;Portfólio</a>
                  
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav navbar-right">
            
              
                
              
              <li><a href="/pt-br/">Página Inicial</a></li>
              <li><a href="#about">Sobre o autor</a></li>
            
          </ul>
        </div>
        <!-- /.navbar-collapse -->
      </div>
      <!-- /.container -->
    </nav>   
    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
  
    <header class="intro-header" style="background-color:#153038;">
  
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              <h1>Object Pascal e Análise do Comportamento</h1>
              <h2 class="subheading">Introdução ao desenvolvimento de interfaces gráficas com Lazarus e Free Pascal</h2>                                
            </div>
          </div>
        </div>
      </div>
    </header>

    <!-- Post Content -->
    <article>
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <ul class="list-inline">
          
              <li>
                <a href="/pt-br/tags/#ciência"><span class="badge">ciência</span></a>
              </li>
          
              <li>
                <a href="/pt-br/tags/#programação"><span class="badge">programação</span></a>
              </li>
          
            </ul>   
          </div>
        </div>
        <hr>
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <h2 id="como-citar-esse-trabalho">Como citar esse trabalho?</h2>

<p>O presente trabalho é uma versão de um capítulo da obra “Introdução ao desenvolvimento de softwares para analistas do comportamento”, E-book gratuito, download completo disponível em: <a href="http://abpmc.org.br/publicacoes.php?inf=14">http://abpmc.org.br/publicacoes.php?inf=14</a></p>

<p>Cite a versão do livro assim:</p>

<blockquote>
  <p>Picanço, C. R. F. (2018). Introdução ao desenvolvimento de interfaces gráficas com Lazarus e Free Pascal. Em H. B. Neves Filho, L. A. B. Freitas &amp; N. C. C. Quinta (Orgs.). Introdução ao desenvolvimento de softwares para analistas do comportamento (pp. 33-88). Campinas: ABPMC.</p>
</blockquote>

<p>Cite esta versão assim:</p>

<blockquote>
  <p>Picanço, C. R. F. (21 de março de 2018). Introdução ao desenvolvimento de interfaces gráficas com Lazarus e Free Pascal [Blog]. Recuperado de: http://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html</p>
</blockquote>

<p>Versões anteriores disponíveis no repositório: https://github.com/cpicanco/blog/</p>

<h2 id="o-objetivo-deste-capítulo-é">O objetivo deste capítulo é:</h2>

<ul>
  <li>Informar o leitor ou leitora sobre a existência de diferentes dialetos derivados do Pascal.</li>
  <li>Situar o leitor ou leitora sobre o dialeto utilizado neste guia.</li>
  <li>Apresentar um recorte da comunidade de desenvolvedores Pascal.</li>
  <li>Apresentar um recorte básico do dialeto Free Pascal.</li>
  <li>Introduzir aspectos básicos do ambiente de programação Lazarus e Free Pascal.</li>
  <li>Introduzir o desenvolvimento de aplicações visuais nesse ambiente por meio de exemplos.</li>
</ul>

<p>Os exemplos foram pensados para uma audiência de analistas do comportamento, especialmente aqueles lidando com participantes de pesquisa que devem interagir com uma interface gráfica. Por meio desses exemplos, a leitora ou leitor será guiado à resolução de problemas recorrentes:</p>

<ul>
  <li>Como apresentar estímulos (antecedentes e consequentes)?</li>
  <li>Como esperar por respostas?</li>
  <li>Como rastrear e registrar tempo e frequência de estímulos e respostas?</li>
</ul>

<h2 id="pré-requisitos">Pré-requisitos</h2>

<ul>
  <li>Inglês: leitura e escrita instrumental.</li>
  <li>Conhecimento básico de informática: usar teclado e mouse.</li>
  <li>Conhecimento básico sobre o sistema operacional de escolha: como executar um programa?</li>
  <li>Conhecimento básico sobre interfaces gráficas comuns, por exemplo, busca por controles visuais: o que são janelas, o que é um menu superior, etc.</li>
</ul>

<h2 id="pascal---breve-histórico">Pascal - Breve histórico</h2>

<p>A linguagem de programação Pascal, como originalmente arquitetada pelo professor Niklaus Wirth (1934-) entre 1968 e 1971 (Jensen &amp; Wirth, 1973) tinha como objetivo servir ao ensino introdutório de programação estruturada em suas aulas. Assim inicia a entrevista de Severance (2012) ao professor Wirth. Embora Wirth também tenha ajudado a montar o sistema em grandes computadores de outras universidades naquele período, ele relata que a popularização de dialetos originados do Pascal só viria na década de 80 com o advento do microcomputador, de sistemas integrados de desenvolvimento e da redução de custo dos compiladores.</p>

<p>Quando comparado com linguagens como BASIC, Assembly, ALGOL e FORTRAN, o Pascal de Wirth possuía um melhor balanço entre legibilidade, modularidade e flexibilidade. Severance (2012), considera que a linguagem, por ser estruturada, era muito mais adequada para a construção de programas com qualidade de produção. Ainda assim, dando continuidade à entrevista, Wirth foi reconhecendo demandas não contempladas pelo Pascal, o que o levou a estendê-lo e reformulá-lo, criando outros dialetos derivados daquele original.</p>

<p>Mas aquela popularização ocorreria por meio de ainda outros dialetos, independentes, com suas próprias extensões e melhorias, alguns inclusive tendo sido adotados como padrão em cursos de introdução à programação. Como consequência, algumas gerações naquele período (70-80) aprenderam a pensar computacionalmente por meio de um dialeto do Pascal, derivado ou original. É razoável considerar, portanto, que algumas gerações entraram no mercado de trabalho tendo um ou outro como primeira linguagem de programação.</p>

<h2 id="pascal---padronização-e-diversificação-comercial">Pascal - Padronização e Diversificação comercial</h2>

<p>Não por acaso, com tal mão de obra disponível, bases de código milionárias foram escritas em dialetos do Pascal; por exemplo, como os primeiros sistemas operacionais da Apple Computers Inc. (1985). Por conta do crescente uso comercial de dialetos derivados do Pascal, o dialeto original foi padronizado (ISO 7185:1983), revisado (ISO 7185:1990) e expandido (ISO 10206:1990) com o objetivo de corrigir ambiguidades e assegurar a sua portabilidade. Atualmente, compiladores como o GNU Pascal (versão 3.4.x) e o Free Pascal (versão 3.x.x) oferecem, em algum nível, suporte a essas padronizações.</p>

<p>Uma linguagem sem ambiguidades e portável permite que um programa, uma vez escrito, seja traduzido para a linguagem da máquina alvo independente do compilador utilizado. A despeito dos esforços, e embora sejam desejáveis de um ponto de vista técnico e prático, tais padronizações não figuram entre os dialetos mais populares derivados do Pascal. Outros dialetos (como o Delphi Pascal, Apple Pascal e Free Pascal) tornaram-se os “padrões de fato” no mercado.</p>

<h2 id="object-pascal---um-dialeto-extendido">Object Pascal - Um dialeto extendido</h2>

<p>Ao longo das décadas de 70 e 80 houve uma popularização da chamada “programação orientada a objetos”. Surgia a necessidade de se estender a sintaxe do Pascal estruturado tornando-o mais permissivo ao novo estilo; originava-se, então, o Object Pascal. A orientação ao objeto tornava-se um modelo de referência para o planejamento e a programação de interfaces gráficas. Foi nesse contexto que interfaces de desenvolvimento integrado como o Turbo Pascal (Borland International Inc, 1984/1983 e sucessores, como o Delphi) e o Lazarus (lançado em 2001, ver <a href="https://en.wikipedia.org/wiki/Lazarus_%28IDE%29">https://en.wikipedia.org/wiki/Lazarus_(IDE)</a>) surgiram.</p>

<h2 id="free-pascal-e-lazarus---um-ambiente-de-desenvolvimento-integrado">Free Pascal e Lazarus - um ambiente de desenvolvimento integrado</h2>

<p>Os exemplos neste guia foram escritos por meio do ambiente integrado de desenvolvimento Lazarus (Lazarus IDE, 2018) e do compilador Free Pascal (Klämpfl et al, 2018). O ambiente contém recursos que reduzem a barreira de entrada na complexa cadeia que é o desenvolvimento de aplicações compiladas. Um compilador é um programa que traduz a sintaxe de alto nível (mais portável), para uma linguagem de baixo nível (específica de uma máquina alvo). O produto final é um arquivo nativamente executável e que não demanda instalação.</p>

<p>Compilador (Free Pascal) e interface (Lazarus) são distribuídos por meio de licenças livres (GPL), de autoria da <em>Free Software Foundation</em>. Diferentemente de licenças privadas, licenças livres não podem ser revogadas. Parte do ambiente também é licenciado (LGPL) de maneira a permitir a distribuição de aplicações comerciais com código fonte privado. Porque tanto aplicações privadas (dentro de certos limites) quanto abertas e livres são permitidas, o ecossistema tende a ter longevidade, fertilidade e diversificação suficientes que tornam uma ampla gama de projetos de engenharia de programas de computador empreendimentos viáveis.</p>

<p>O ambiente está disponível para sistemas operacionais como o OSX, Windows e baseados no <em>kernel</em> Linux (Debian, Ubuntu) e agrega uma grande comunidade de desenvolvedores independentes. Os principais meios de informação e comunicação nesse ecossistema são:</p>

<ul>
  <li><a href="http://wiki.freepascal.org/">A wiki</a>: http://wiki.freepascal.org/</li>
  <li><a href="http://forum.lazarus.freepascal.org/">O fórum</a>: http://forum.lazarus.freepascal.org/</li>
  <li>As listas de emails:
    <ul>
      <li><a href="http://lists.lazarus.freepascal.org/mailman/listinfo/lazarus">Lazarus</a>:http://lists.lazarus.freepascal.org/mailman/listinfo/lazarus</li>
      <li><a href="https://www.freepascal.org/maillist.var">Free Pascal</a>:https://www.freepascal.org/maillist.var</li>
    </ul>
  </li>
  <li>Os sites oficiais:
    <ul>
      <li><a href="http://packages.lazarus-ide.org/">Pacotes</a>: http://packages.lazarus-ide.org/</li>
      <li><a href="https://foundation.freepascal.org/">Fundação</a>: https://foundation.freepascal.org/</li>
      <li><a href="http://lazarus-ide.org/">Lazarus</a>: http://lazarus-ide.org/</li>
      <li><a href="https://www.freepascal.org/">Free Pascal</a>: https://www.freepascal.org/</li>
    </ul>
  </li>
  <li><a href="http://bugs.freepascal.org/">O rastreador de bugs</a>: http://bugs.freepascal.org/</li>
</ul>

<p>Diversas coleções de unidades, componentes e pacotes reunidos nas chamadas “bibliotecas” já vem pré-instalados. Eles permitem a execução de tarefas gerais de programação:</p>

<ul>
  <li>Free Pascal Runtime Library (RTL).</li>
  <li>Free Pascal Component Library (FCL).</li>
  <li>Lazarus Component Library (LCL).</li>
</ul>

<p>Outras coleções de terceiros também frequentemente utilizadas estão reunidas por meio do pacote “Gerenciador Online de Pacotes”. O pacote é distribuído juntamente com o Lazarus e pode ser instalado por meio do menu “Pacotes”, opção “Instalar pacotes”, item “OnlinePackageManager” na lista à direita.</p>

<p>Ao explorar o ecossistema por meio de buscadores online, seja em busca de ajuda, seja em busca de contribuições de terceiros, utilize palavras-chave como “free pascal”, “lazarus forum”, “component”, “package”, juntamente com os termos específicos de seu interesse.</p>

<h2 id="free-pascal-e-lazarus---instalação-e-configuração-do-ambiente-de-desenvolvimento">Free Pascal e Lazarus - Instalação e configuração do ambiente de desenvolvimento.</h2>

<p>Baixe os arquivos de instalação correspondentes para o seu sistema no sítio de hospedagem oficial (<a href="https://www.lazarus-ide.org">https://www.lazarus-ide.org</a>). Em seguida execute o instalador (ou instaladores, se Linux e OSX). Caso seja solicitado, forneça os privilégios de administrador do sistema operacional ao instalador. O processo de instalação e configuração mínima é automático.</p>

<p>Este guia fará referência aos nomes dos controles da interface Lazarus tal como traduzidos para o português brasileiro, portanto recomenda-se a escolha deste idioma ao longo da instalação. Opcionalmente, após a instalação, altere o idioma no menu superior Ferramentas-&gt;Opções da IDE-&gt;Ambiente-&gt;Geral-&gt;Idioma. Opcionalmente você também pode trocar os esquemas de cores das janelas. Diversos esquemas de cores para as janelas estão disponíveis. Para mais informações, consulte o endereço: <br />
<a href="http://wiki.lazarus.freepascal.org/UserSuppliedSchemeSettings">http://wiki.lazarus.freepascal.org/UserSuppliedSchemeSettings</a></p>

<h2 id="lazarus---criando-e-executando-uma-aplicação">Lazarus - criando e executando uma aplicação</h2>

<p>Ao executar o Lazarus pela primeira vez (por meio do comando “startlazarus” em sistemas Linux), uma aplicação (programa com uma interface gráfica) é criada automaticamente. Execute a aplicação pressionando F9 (Executar). Essa aplicação padrão é uma janela flutuante (ou formulário) com funcionalidades básicas como fechar, minimizar, maximizar, restaurar, mover, redimensionar, entre outras. Essa janela (ver Figura 1, janela 4) também já vem preparada para receber eventos como aqueles produzidos por mouse e teclado.</p>

<p>
<img class="img-responsive center-block" src="/media/blog/laz_fpc_ac_intro/Figure1.jpg" alt="Janelas Utilizadas neste guia." />
</p>

<p>Figura 1. Janelas utilizadas neste guia. Legenda: (1) menu superior do Lazarus; (2) inspetor de objetos; (3) editor de código; (4) janela principal da aplicação; (5) mensagens; (6)console.</p>

<p>Para a execução do código na seção de sintaxe (adiante) recomenda-se criar um programa mais simples para cada elemento sintático de seu interesse. Para criar um programa mínimo, clique em “Projetos”, “Novo Projeto”, “Programa Simples”.</p>

<h2 id="lazarus---encerrando-uma-aplicação">Lazarus - encerrando uma aplicação</h2>

<p>Ao executar seu programa por meio da interface de desenvolvimento, existem ao menos duas maneiras de se encerrar uma aplicação: normalmente ou forçadamente. Para fechar a aplicação normalmente, utilize o comando correspondente na barra superior da janela (no Windows, por exemplo, clique no xis no canto superior direito). Para forçar o fechamento, selecione uma janela do Lazarus, por exemplo clicando sobre a janela “Editor de Código” (Figura 1, janela 3), e pressione CRTL+F2 (ou clique no botão “Parar” do menu superior da janela principal do Lazarus). O primeiro método permite avaliar a ocorrência de erros na cadeia de eventos de encerramento da aplicação. O segundo não produz a cadeia normal de eventos de encerramento e permite a interrupção da aplicação (travada), especialmente quando erros lógicos produzem espera infinita.</p>

<h2 id="lazarus---salvando-o-projeto-de-uma-aplicação">Lazarus - salvando o projeto de uma aplicação</h2>

<p>Após fechar a aplicação, pressione CRTL+S e salve o projeto. Recomenda-se sempre renomear os nomes padrões para nomes que resumem a função do arquivo. O código fonte da aplicação padrão é composto por três arquivos principais. Dois arquivos (unit1.pas e unit1.lfm) compõe um “formulário” ou “janela” e o outro arquivo (project1.lpr) compõe um “projeto” ou “programa”. Adicionalmente, um arquivo de configuração do projeto (project1.lpi) e arquivos de recursos auxiliares também serão automaticamente criados ao salvar. Neste guia, apenas o arquivo “unit1.pas” será editado diretamente por você. Ao salvar, renomeie esse arquivo para “Forms.Main.pas”. Em seguida o programa permitirá que você renomeie o arquivo de configuração do projeto. Renomeie para “ProjetoPiloto.lpi”. Como muitos arquivos estão envolvidos, recomenda-se reservar uma pasta para cada projeto.</p>

<h2 id="lazarus---depurando-uma-aplicação">Lazarus - depurando uma aplicação</h2>

<p>Um depurador (debugger) é um programa que auxilia na detecção e correção de erros no seu programa. Ao executar a aplicação padrão por meio do Lazarus (pressionando F9, por exemplo) informações que permitem melhor depuração são adicionadas automaticamente ao executável. O depurador padrão utilizado é o GNU Debugger (GDB). Uma descrição detalhada de estratégias de depuração está fora do escopo do presente guia. Entretanto, recomenda-se explorar duas delas: (a) Observação em tempo real do conteúdo de variáveis por meio do menu Exibir-&gt;Janelas de depuração-&gt;Observadores e (b) Adição de ponto de parada (Break Point) em linhas de código permite execução linha a linha por meio dos controles “Passar dentro” (F7) e “Passar sobre” (F8).</p>

<p>Para os objetivos deste guia, uma estratégia mais básica de depuração será adotada na seções seguintes por meio da janela “Console” (Figura 1, janela 6). Para exibi-la, pressione CRTL+ALT+O. Ao executar uma aplicação por meio do Lazarus, essa janela é a saída padrão do texto escrito por meio do <strong>WriteLn</strong>, um construto básico da linguagem apresentado nas seções seguintes. Escrever texto no console é uma estratégia simples e eficiente de apresentar informações sobre o programa e saber se ele realmente está fazendo o que deveria estar fazendo.</p>

<h2 id="free-pascal---sintaxe-básica">Free Pascal - Sintaxe básica</h2>

<p>As seções seguintes foram planejadas como um recurso de <strong>consulta</strong> e para permitir a <strong>leitura corrida</strong>. Não tente decorar nada! Ao consultar, você deve executar, testar e explorar cada elemento sintático de seu interesse copiando e colando no editor de código. Lembre-se, é muito importante que você crie um programa simples para cada elemento sintático de seu interesse. Dessa forma você estará se organizando e criando condições para recorrer aos seus próprios programas de teste quando precisar lembrar de algo. Veja os passos para criar um programa simples na seção “criando e executando uma aplicação” acima.</p>

<h3 id="comentários">Comentários</h3>

<p>Textos comentados são ignorados pelo compilador e permitem a documentação do funcionamento e significado de trechos do código. Comente uma linha inteira usando duas barras no início da linha:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // Esta linha está comentada, pois inicia com duas barras.
</code></pre></div></div>

<p>É possível também inserir um comentário ao final da linha:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // Esta linha está comentada
 Este trecho não está comentado, // mas este está.
</code></pre></div></div>

<p>Comente diversas linhas por meio de chaves:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // Esta linha está comentada
 {
    Este trecho também está comentado,
    pois está entre chaves simples.
 }
</code></pre></div></div>

<p>Comente um pedaço de texto dentro de uma linha por meio de chaves:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // Esta linha está comentada
 Este trecho não, { este sim } este não.
</code></pre></div></div>

<h3 id="programa-blocos-início-fim">Programa, Blocos, Início, Fim</h3>

<p>Um programa pascal é um conjunto de blocos. Ele deve conter no mínimo um bloco de declaração de seu título e um bloco de comandos. O ponto final ao final demarca o final de um programa. Outros comandos, blocos de comandos e declarações dentro de um módulo devem ser finalizados com ponto e vírgula:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>program ProjetoPiloto // declara o identificador ProjetoPiloto
;  // finaliza o bloco de declaração do identificador do programa
begin  // inicia o bloco de comandos central
  WriteLn('Olá Mundo!'); // escreve o texto 'Olá Mundo!' e uma linha no console 
end. // finaliza o bloco de comandos central e o módulo
</code></pre></div></div>

<p>A linguagem não diferencia maiúsculas de minúsculas, portanto o seguinte programa é idêntico ao anterior:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PROGRAM projetopiloto;
BEGIN                   
  writeln('Olá Mundo!');              
END.                    
</code></pre></div></div>

<p>Com exceção dos separadores entre identificadores, a linguagem não é sensível à indentação (recuos, parágrafos, espaçamentos, etc.) por meio de caracteres não imprimíveis como o ‘tab’, ‘espaço’ ou ‘final de linha’. Isso significa que o seguinte programa também é idêntico ao anterior:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>program projetopiloto;begin WriteLn('Olá Mundo!');end.
</code></pre></div></div>

<p>Embora idêntico, diferentes convenções de indentação existem com o objetivo de melhorar a legibilidade do código. A linguagem permite que você crie sua própria convenção, mas recomenda-se o uso de convenções existentes.</p>

<p>O arquivo contendo o identificador “program” é o módulo principal de um programa. Mas um programa frequentemente reuni outros arquivos chamados de “unidades”.</p>

<h3 id="unidades">Unidades</h3>

<p>Uma unidade é um módulo que pode ser reutilizado por outros módulos. Cada unidade possui, necessariamente, um bloco público (interface), visível a outros módulos, e um bloco privado (implementação), invisível a outros módulos. Um programador deve ser capaz de usar uma unidade conhecendo apenas a interface dela mantendo-se agnóstico sobre a implementação. Identifique os blocos público e privado da unidade “Unit1” por meio dos comentários a seguir:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unit Unit1; // inicia a unidade Unit1
 
interface   // inicia o bloco público da unidade                
 
uses   // a palavra "uses" inicia um "bloco de uso" e permite usar outras unidade
 Unit2, Unit3;  // as unidades 2 e 3 estão sendo usadas
 
{  As interfaces das unidades 2 e 3 são visíveis
    em toda a unidade 1 (esta unidade).}
 
implementation  // final do bloco público e início do bloco privado da unidade
 
uses Unit4;           
 
{  Mas a interface da unidade 4 é visível apenas
    na implementação da unidade 1 (esta unidade). }
 
end.            // final da unidade
</code></pre></div></div>

<p>A unidade anterior (Unit1) usa três outras unidades (Unit2, Unit3 e Unit4). Se duas unidades diferentes declaram interfaces iguais, a interface da última unidade na lista é usada evitando, portanto, conflitos.</p>

<p>Que tal escrever o dia atual no console reaproveitando as funcionalidades de unidades existentes? A unidade “DateUtils” contém a função “Today” em sua interface. Essa função tem como resultado o dia atual no formato de data (o tipo “TDateTime”). Mas esse formato não é legível, então será necessário convertê-lo para um formato de texto legível. Para isso, a unidade “SysUtils” contém a função “DateTimeToStr” em sua interface. Essa função converte uma data para texto:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>program ProjetoPiloto;
uses DateUtils, SysUtils;
begin
  WriteLn(DateTimeToStr(Today));
end.
</code></pre></div></div>

<p>Os aspectos sintáticos de uma “função” serão descritos mais adiante. Neste momento, apenas note o seguinte: A função “Today” está entre os parênteses da função “DateTimeToStr” que, por sua vez, está entre os parênteses do constructo “WriteLn”. Você pode ler essa linha dessa forma: “Today” retornará um resultado para “DateTimeToStr” que, por sua vez, retornará outro resultado para “WriteLn” que, por fim, escreverá o texto correspondente no console.</p>

<h3 id="atribuição-variáveis-constantes-e-tipos">Atribuição, Variáveis, Constantes e Tipos</h3>

<p>Uma variável é um identificador associado a um espaço reservado na memória do computador. Em outras palavras, uma variável permite salvar um resultado na memória e recuperá-lo quando for necessário. Toda variável possui um tipo (um formato) e precisa estar declarada em um bloco antes de ser usada. Identifique o bloco de declaração de variáveis por meio dos comentários a seguir:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var                  // inicia um bloco de declaração de variáveis
  b : boolean = true; // declara ‘b’ como um tipo ‘boleano’ inicializando-o com true
  i : integer = -1;   // declara ‘i’ como um ‘número inteiro inicializando-o com -1
  s : string  = 'Texto'; // declara ‘s’ como um texto inicializando-o com "Texto" 
begin
  WriteLn(b);            // converte o valor para texto e o mostra no console
  WriteLn(i);            // converte o valor para texto e o mostra no console
  WriteLn(s);            // mostra o texto no console
end. 
</code></pre></div></div>

<p>Variáveis podem receber (atribuição de) valores por meio do sinal “:=”. A leitura se dá da direita para a esquerda: “Variável := Valor”. Diferentes valores de um mesmo tipo podem ser atribuídos a uma variável no bloco de comandos. Constantes simples, diferentemente de variáveis, podem ser declaradas, mas não podem receber atribuição de valores.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const       // inicia um bloco de declaração de constantes
  tab = #9; // declara uma constante com um caractere não imprimível (tab)
var          
  b : boolean;  // declara ‘b’ como boleano  
  i : integer;  // declara ‘i’ como inteiro
  s : string;   // declara ‘s’ como texto 
begin
  b := false;   // atribui false à variável ‘b’
  i := 10;      // atribui 10 à variável ‘i’
  s := 'texto'; // atribui "texto" à variável ‘s’
 
  // imprime as variáveis no console usando o tab como separador
  WriteLn(b, tab, i, tab, s); 
 
  // tab := #32; isso não é possível, pois ‘tab’ é uma constante
end. 
</code></pre></div></div>

<h3 id="operadores">Operadores</h3>

<p>Operadores são símbolos reservados para operações comuns sobre variáveis de tipos conhecidos. Consulte o guia de referência da linguagem para informações detalhadas sobre todos os operadores suportados (<a href="https://www.freepascal.org/docs-html/ref/refse84.html">https://www.freepascal.org/docs-html/ref/refse84.html</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
  b : boolean = false;
  i : integer = 10;
  s : string  = 'texto';
begin
  // Operações Boleanas
  b := not B;       // inverte o valor de B (para true)
  b := not B;       // inverte o valor de B (para false)
  b := 10 &gt; 9;      // dez é maior do que nove? true
  b := 10 &lt; 9;      // dez é menor do que nove? false
  b := 10 = 9;      // dez é igual à nove? false
  b := 10 &lt;&gt; 9;     // dez é diferente de 9? true
 
  //  cuidado! a comparação entre texto diferencia maiúsculas e minúsculas
  b := s = 'texto'; // os textos são iguais? true
  b := s &lt;&gt; 'Texto';// os textos são diferentes! true
 
  // Operações Aritméticas
  i := -i;          // inverte o sinal de i para negativo
  i := -i;          // inverte o sinal de i para positivo
  i := 10 + 10;     // soma entre dois inteiros
  i := 10 - 1;      // diferença entre dois inteiros
  i := 10 * 10;     // multiplicação entre dois inteiros
  i := 10 div 10;   // divisão entre dois inteiros
  i := 10 mod 3;    // resto da divisão entre dois inteiros
 
  // Operações com texto
  s := 'texto'+'texto'+'texto';     // concatenar texto  
end.
</code></pre></div></div>

<p>O que você faria para inspecionar o resultado de cada operação armazenado nas variáveis “i”, “b” e “s”?</p>

<h3 id="condições">Condições</h3>

<p>Você frequentemente precisará que um programa realize operações condicionalmente. Condições podem ser declaradas por meio de dois tipos de estruturas.</p>

<h4 id="if--then--else">if … then … else</h4>

<p>O primeiro tipo condicional permite testes boleanos, testes que admitem apenas dois resultados (verdadeiro e falso) e, consequentemente, a bifurcação entre dois caminhos:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
  i : integer;
begin 
  {
    Observação:
    True e False são os valores boleanos
    pré-definidos pela linguagem
  }
 
  // neste caso, o uso de um valor pré-definido torna a condição sempre verdadeira
  if True then
    begin 
      i := 1; // então este comando sempre será executado
    end
  else
    begin
      i := 0; // e este nunca será executado
    end;
 
  // neste caso a condição é sempre falsa
  if False then
    begin 
      i := 1; // então este comando nunca será executado
    end
  else
    begin
      i := 0; // e este sempre será executado
    end;
 
  // neste momento, o que será escrito no console?
  if i = 0 then WriteLn(i) else WriteLn('A');
 
  // e agora, o que será escrito no console?
  if i = 0 then WriteLn('A') else WriteLn(i);
end.
</code></pre></div></div>

<h4 id="case--of--else-">“case … of … else …”</h4>

<p>O segundo tipo condicional permite testes sobre valores e texto. A bifurcação pode ocorrer entre diversos resultados:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
  i : integer = 0;  // inicializa i com o valor 0
  s : string = 'a'; // inicializa s com o texto 'a'
begin
  // casos sobre valores
  case i of
    0 :           // caso i seja igual a 0
      i := 1; // este comando será executado, pois i é igual a zero
    1 :           // caso i seja igual a 1
      i := 2;     
    2 :           // caso i seja igual a 2
      i := 3;          
  else
  // este comando será executado se nenhum dos casos especificados ocorrer
    i := -1;      
  end;
 
  // casos sobre texto
  case s of
    'a'    : i := 0; // este comando será executado, pois s é igual a 'a'
    'b'    : i := 1; // caso s seja 'b'
    'casa' : i := 2; // caso s seja 'casa'
  else
    i := -1;          
  end;
end.
</code></pre></div></div>

<h3 id="laços-de-repetição">Laços de repetição</h3>

<p>Existem três tipos de laços de repetição. Dois deles permitem repetir um bloco de comandos “até que” ou “enquanto” uma condição for verdadeira. O outro permite repetir um bloco de comandos de acordo com um intervalo de valores.</p>

<h4 id="repeat--until">repeat … until</h4>

<p>Este laço permite testar uma condição de saída após um bloco de comandos, ou seja, permite executar um bloco de comandos no mínimo uma vez e repeti-lo até que uma condição de saída seja verdadeira.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
  i : integer;
begin
  i := 100; 
  repeat            
    i := i + 1;    // executa o bloco de comandos primeiro
  until i &lt; 100;   // testa a condição de saída ao final 
  // portanto i será igual a 101
end.
</code></pre></div></div>

<h4 id="while--do">while … do</h4>

<p>Este laço permite testar uma condição de saída antes de um bloco de comandos, ou seja, se a condição for falsa o bloco de comandos não executa nenhuma vez. Ao contrário, se for verdadeira, repetirá enquanto a condição for verdadeira.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
  i : integer;
begin
  // repetir enquanto uma condição for verdadeira:
  i := 100;
  while i &lt; 100 do // a condição de saída é executada primeiro
  begin            // portanto este bloco não será executado
    i := i + 1;  
  end;
 
  i := 100;
  while i = 100 do // condição verdadeira, portanto
    i := i + 1;    // este bloco será executado uma vez
 
  // condições de saída customizadas podem ser criadas
  // com o procedimento de saída de laço "Break" e condições
 
  // o laço a seguir executaria infinitamente 
  // pois True é uma variável do sistema e não muda
  // a única maneira de sair desse laço é por meio
  // do procedimento de saída de laço "Break"
  i := 0;
  while True do 
  begin
    WriteLn(i);       // escreva o valor de i no console
    i := i + 1;       // incremente i
    if i &gt; 4 then     // se i maior do que 4 (condição de saída) então 
      Break;          // saia do laço infinito
  end;
  // WriteLn produzirá "0, 1, 2, 3, 4" no console
 
  // também é possível pular comandos dentro do bloco de repetições
  // por meio do procedimento "Continue"
  i := 0;
  while True do     // execute infinitamente
  begin             // início do bloco de repetições
    if i &lt; 4 then   // se menor do que 4
    begin
      WriteLn(i);   // escreva o valor de i no console                    
      i := i + 1;   // incremente 1
      Continue;     // e continue do início
    end;
                  // se 5 ou maior
    i := i + 1;     // incremente 1
    WriteLn(i);     // escreva o valor de i no console
    Break;          // saia do laço infinito
  end;              // fim
  // WriteLn produzirá "0, 1, 2, 3, 5" no console
  // o número quatro foi pulado 
end.
</code></pre></div></div>

<h4 id="for--to--do--for--downto--do">for … to … do / for … downto … do</h4>

<p>Este laço permite repetir de acordo com um intervalo.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
  i : integer;
begin
  for i := 0 to 9 do // do menor para o maior
    begin
      WriteLn(i);  // 0, 1 .. 9
    end;
   
  for i := 9 downto 0 do   // do maior para o menor
    begin
      WriteLn(i); // 9, 8 .. 0
    end;
   
  { Esses laços também permitem o uso dos procedimentos  Break e Continue }    
end.
</code></pre></div></div>

<h4 id="vetores-e-listas">Vetores e Listas</h4>

<p>Laços de repetição geralmente se combinam com vetores e listas. Um vetor (array) é uma série de itens indexados. Cada item possui um índice e um tipo. Por padrão o primeiro item de um vetor possui índice 0. Vetores podem ser estáticos ou dinâmicos. Vetores estáticos possuem um tamanho fixo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const
  space = #32;
var
  // declara e inicializa um vetor estático
  names : array [0..4] of string = ('joao', 'maria', 'rafael', 'thais', 'laura'); 
 
  // declara uma variável de tipo igual ao do vetor
  name : string;
 
  // apenas inteiros podem servir como índice de vetores
  i : integer;
begin
// percorra os items de um vetor sem se preocupar com seus índices
  for name in names do
    WriteLn(name);
 
  // percorra os items de qualquer vetor por meio de seus índices
  for i:= Low(names) to High(names) do
    begin
      WriteLn(i, space, names[i]);
    end;     end.
</code></pre></div></div>

<p>Vetores dinâmicos possuem um tamanho variável:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
  numbers : array of integer; // declara um vetor dinâmico
  number : integer;
begin
  SetLength(numbers, 2);  // inicializa um vetor com 2 itens  
 
  // retorna o tamanho de um vetor, neste caso igual a 2
  // Length(numbers);     
 
  // retorna o maior índice de um vetor, neste caso igual a 1
  // High(numbers);       
 
  // retorna o menor índice de um vetor, neste caso igual a 0
  // Low(numbers);        
 
  // atribui um valor ao primeiro item do vetor
  numbers[0] := 100;      
 
  // atribui um valor ao segundo item do vetor
  numbers[1] := 200;      
 
  // expande o vetor, agora ele possui 3 itens
  SetLength(numbers, Length(numbers)+1);  
 
  // atribui um valor ao terceiro item, 
  numbers[2] := 300;
 
  // reduz um vetor, agora ele possui 2 itens
  SetLength(numbers, Length(numbers)-1);  
 
  // ao reduzir um vetor,
  // a liberação ocorre na ordem do maior para o menor índice
  // de tal forma que os itens iniciais
  // não são alterados ao reduzir o tamanho
  for number in numbers do WriteLn(number);  
end.
</code></pre></div></div>

<p>Entretanto, em geral, não é recomendado usar um vetor de texto, mas sim uma lista de texto. Uma lista de texto (o tipo “TStringList”) é uma classe e classes serão apresentadas com mais detalhes nas seções seguintes. No momento, note que uma lista de texto é enumerável. Tipos enumeráveis podem ser percorridos como vetores, possibilitando o acesso a cada um de seus itens. Classes enumeráveis, portanto, podem ser percorridas como vetores.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uses Classes; // torna o tipo ‘TStringList’ visível neste módulo
 
var
  Names : TStringList; // declara Names como do tipo TStringList
  name : string;      
begin
  // Note que o caractere "ponto" (.) é utilizado
  // para acessar o conteúdo de classes e objetos
 
  // inicializa um objeto do tipo lista de texto (TStringList)
  Names := TStringList.Create;         
 
  // atribui um texto delimitado à lista
  Names.DelimitedText := 'thais maria clara bárbara joana'; 
 
  // adiciona um item ao final da lista
  Names.Append('marcela');                
 
  // percorre a lista escrevendo cada nome
  for name in Names do WriteLn(name);  
 
  // libera a lista da memória
  Names.Free; 
 
  // Sempre libere as listas da memória ao final!
end.
</code></pre></div></div>

<h3 id="procedimentos-funções-argumentos">Procedimentos, Funções, Argumentos</h3>

<p>Procedimentos e funções são estruturas que permitem a modularização e a reutilização de blocos de comandos. Por exemplo, ao invés de repetir diversas vezes os mesmos comandos, você pode declarar um procedimento contendo esses comandos. Considere os seguintes comandos:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
 i : integer;
begin
 
  i := 1;
  WriteLn('-------------------------------------');
  WriteLn('-    bloco de comandos    -');
  WriteLn('-------------------------------------'); WriteLn(i);
 
  i := 2;
  WriteLn('-------------------------------------');
  WriteLn('-    bloco de comandos    -');
  WriteLn('-------------------------------------'); WriteLn(i);
 
  i := 3;
  WriteLn('-------------------------------------');
  WriteLn('-    bloco de comandos    -');
  WriteLn('-------------------------------------'); WriteLn(i);
 
  i := 4;
  WriteLn('-------------------------------------');
  WriteLn('-    bloco de comandos    -');
  WriteLn('-------------------------------------'); WriteLn(i);
end.
</code></pre></div></div>

<p>Uma alternativa para evitar repetições seria declarar um procedimento:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // declara o procedimento WriteBloc com o argumento ABlocNumber
 procedure WriteBloc(ABlocNumber : integer);
  begin
    WriteLn('-------------------------------------');
    WriteLn('-    bloco de comandos    -');
    WriteLn('-------------------------------------');
    WriteLn(ABlocNumber);
 end;  
 
  var
    i : integer;
      
  begin
    i := 1;
    WriteBloc(i); // chama o procedimento
 
    i := 2;
    WriteBloc(i);
 
    i := 3;
    WriteBloc(i);
 
    i := 4;
    WriteBloc(i);
 end.
 
Um laço evitaria ainda mais repetições:
 
  begin
    for i := 1 to 4 do WriteBloc(i);
 end.
</code></pre></div></div>

<p>Todo procedimento ou função possui um identificador e uma assinatura com ou sem argumentos. Procedimentos podem ser declarados de diferentes maneiras no contexto de uma unidade, mas só é possível chamá-los de acordo com as regras de visibilidade da unidade:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> unit Unit1;
  {   apenas a assinatura de procedimentos pode ser
    declarada na interface de uma unidade }
 interface 
 
  { procedimentos possuem ou não argumentos de entrada em sua assinatura }
  // declara o identificador PublicCommand como um procedimento sem argumentos:
 procedure PublicCommand;
 
  // declara um procedimento com um argumento:
 procedure AnotherPublicCommand(AString : string);
 
  // declara um procedimento com dois argumentos:
 procedure YetAnotherCommand(AString1 : string; AInteger : integer);
 
  { procedimentos declarados na interface devem ser redeclarados na implementação }
  implementation
  { procedimentos declarados apenas na implementação
     não podem ser vistos por outras unidades usando esta unidade }
 procedure PrivateCommand;
  begin
 end;
 
 procedure PublicCommand;
    procedure NestedCommand; 
    begin { procedimentos declarados dentro de procedimentos, chamados aninhados,
    end;  são visíveis apenas em seu bloco de execução }
  begin
    NestedCommand;  // executa o comando aninhado deste procedimento
    PrivateCommand; // executa um comando privado da unidade
 end;
 
 procedure AnotherPublicCommand(AString: string);
    procedure NestedCommand;
    begin
    end;
  begin
    NestedCommand;  // executa o comando aninhado deste procedimento
    PrivateCommand; // executa um comando privado da unidade
 end;
 
 procedure YetAnotherCommand(AString1: string; AString2: string);
 const                // constantes podem ser locais
    LConst = 10; 
 var                  // variáveis também podem ser locais
    LInteger : integer; 
    LBoolean : boolean;
    LString  : string;
    procedure LocalCommand; 
    begin
 
    end;
  begin
 end; 
 end.
</code></pre></div></div>

<p>Os argumentos de um procedimento podem receber prefixos que determinam como uma variável será passada ao procedimento.
Um argumento sem prefixos é uma cópia da variável de entrada, isso significa que a cópia será modificada dentro do procedimento e a variável original não será modificada:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // declarando o procedimento AssignParameter
 procedure AssignParameter(AValue : integer):
 begin
    AValue := 20;
 end;
  {...}
  var
   i : integer = 10;
  begin
    AssignParameter(i); // chamando o procedimento AssignParameter
    // note que i permanece igual a 10
 end;
</code></pre></div></div>

<p>O prefixo “var” permite alterar a variável original de entrada:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // assinatura do procedimento Inc
 procedure Inc(var AVariable: TOrdinal);
  {...}
 var 
    InputVariable : integer = 0;      // inicializa i com o valor inicial 0
 begin // chamando o procedimento Inc
    Inc(InputVariable);               // incrementa i
    // InputVariable = 1  
 end;
</code></pre></div></div>

<p>O prefixo “out” permite alterar a variável original, mas ignora seu valor inicial.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // assinatura do procedimento WriteStr
 procedure WriteStr(out OutputString: string; Args: Arguments);
  {...}
  var                                       // OutputString não possui um valor inicial, 
  OutputString : string;// pois não foi inicializada
  i : integer = 50;
  begin // chamando o procedimento WriteStr, ele converte i para texto 
    WriteStr(OutputString, i);// e inicializa Outputstring com '50'
    // OutputString = '50'
 end;
</code></pre></div></div>

<p>O prefixo “const” informa que a variável não será alterada:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // assinatura do procedimento ReadStr
 procedure ReadStr(const S: string; Args: Arguments);
  {...}
  // chamando o procedimento ReadStr
  var
    ConstantInput : string = '10 20 Texto';
    i1, i2 : integer;
    s : string;
  begin
  {
 
    Importante
    ****************
    Argumentos do tipo "Arguments" são especiais.
    Eles não podem ser redeclarados pelo programador, apenas usados por ele.
    O programador pode incluir diversos argumentos de tipos conhecidos
    na posição de um argumento "Arguments". 
    O compilador fará as conversões necessárias se elas forem possíveis.
    ****************
  }
    ReadStr(ConstantInput, i1, i2, s);
   
    // ConstantInput = '10 20 Texto'  
    // i1 = 10
    // i2 = 20
    // s = 'Texto'
 end;
</code></pre></div></div>

<p>Note que as funções “Inc”, “WriteStr” e “ReadStr” são funções da unidade “System”. Funções são exatamente como procedimentos, mas necessariamente retornam um resultado de um tipo específico. Ao escrever uma função, use a variável “Result” para salvar o resultado. Essa variável é automaticamente declarada e acessível dentro de qualquer função:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // declara uma função sem argumentos que retorna um boleano:
 function GetBoolean : Boolean;
 begin
    Result := true;
 end;
 
 // declara uma função que retorna um texto:
 function GetString : string;
 begin
    Result := 'texto';
 end;
 
 // declara uma função que retorna um valor inteiro:
 function GetInteger : integer;
 begin
   Result := 0;
 end;
</code></pre></div></div>

<p>Conversões entre tipos frequentemente são realizadas por meio de funções. Funções comuns de conversão estão localizadas na unidade “SysUtils”.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uses SysUtils;   // unidade com muitas funções de conversão
 
{...}
 
 s := IntToStr(i); // converte um inteiro para texto 
 i := StrToInt(s); // converte um texto para inteiro
 i := StrToIntDef(s, 0); // converte um texto para inteiro, em caso de erro retorna 0
 b := StrToBoolDef(s, false) // converte um texto para boleano
                             // em caso de erro retorna false
</code></pre></div></div>

<p>Frisa-se que argumentos do tipo “Arguments” (comuns na unidade “System”) são exclusivos do compilador e não podem ser redeclarados. Se um número incerto de parâmetros de um mesmo tipo for necessário, use um vetor como argumento:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // declara o procedimento ManyStrings
 procedure ManyStrings(AStrings : array of string);
  var
    i : integer;
    s : string;
  begin
    for i := Low(AStrings) to High(AStrings) do
    begin
      s := AStrings[i];
    end;
 end;
 
  // chamando o procedimento ManyStrings
 
  begin
    ManyStrings(['texto1', 'texto2', 'texto3']);
    ManyStrings(['texto1', 'texto2']);
    ManyStrings(['texto1']);
 end;
</code></pre></div></div>

<h3 id="classes-propriedades-e-eventos">Classes, Propriedades e Eventos</h3>

<p>Variáveis, procedimentos e funções também permitem a construção de eventos, propriedades e classes de objetos. A arquitetura de eventos, propriedades e classes está fora do escopo do presente guia. Para informações detalhadas sobre arquitetura, procure por padrões de projeto (<em>Design Patterns</em>) nas ferramentas de busca, eles são, frequentemente, independentes de linguagens.</p>

<p>Ainda assim, é possível usar arquiteturas existentes ou apenas usar aspectos delas, mantendo-se agnóstico sobre os detalhes. Para isso, o objetivo no momento é de compreender a sintaxe de classes, e como fazer uso de propriedades e eventos de classes existentes.</p>

<p>No contexto de programas orientados a objetos, eventos devem ser entendidos como um tipo de mensagem que um objeto pode enviar ou receber de outros objetos. Objetos são instâncias criadas por meio de classes. Classes são, literalmente, abstrações de coisas no mundo que possuem relações hierárquicas entre si. Essas abstrações tem o objetivo, dentre outros, de apreender o comportamento de coisas no mundo e tornar o programa intuitivo para aqueles que conhecem essas coisas no mundo. Por exemplo, considere uma lista de texto. O que normalmente se faz com uma lista de texto?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var
  list : TStringList;
begin
  // criar uma lista de texto, isto é, reservar um espaço na memória para ela
  list := TStringList.Create;
 
  // limpar o conteúdo da lista
  list.Clear;
 
  // adicionar um texto ao final da lista
  list.Append('texto 1');
 
  // adicionar outro texto ao final da lista
  list.Append('texto 2');
 
  // alternar a posição de textos na lista 
  list.Exchange(0, 1);
 
  // liberar a lista da memória
  list.Free;
end; 
</code></pre></div></div>

<p>Objetos frequentemente possuem eventos associados a eles. Sintaticamente, um evento é um tipo que contém a assinatura de um método:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> type // inicia um bloco de declaração de tipo
    TNotifyEvent = procedure(Sender : TObject) of object;
 
  // O tipo de evento "TNotifyEvent" está declarado na unidade "Classes"
 
  // "Sender" é o objeto que enviou a mensagem
  // ou, em outras palavras, o objeto que disparou o evento
</code></pre></div></div>

<p>Eventos podem ser declarados como variáveis de uma classe e acessados diretamente ou por meio de propriedades. No pascal orientado a objetos, todas as classes possuem os métodos da classe “TObject”. Em um jargão técnico, todas as classes herdam os métodos de um ancestral comum que é o “TObject”. Isso significa que todas as classes podem, em alguma medida, conversar entre si por meio de eventos que tenham um “TObject” como argumento. A seguir a classe “TMyForm” é declarada tendo como ancestral a classe “TForm”. A classe “TForm” abstrai o comportamento básico esperado de uma janela. Note que um novo evento “NotifyEvent” foi declarado. Identifique como atribuir um valor ao evento e como dispará-lo por meio dos comentários a seguir:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface
   
type
  TMyForm = class(TForm)
    procedure SomeEvent(Sender : TObject);  
  private
    // internamente, eventos são uma variável
    FNotifyEvent : TNotifyEvent; 
   
    // e possuem um procedimento de escrita
    procedure SetNotifyEvent(ANotifyEvent : FNotifyEvent);
  public
   
    // eventos frequentemente são acessados por meio de propriedades
    property NotifyEvent : TNotifyEvent read FNotifyEvent write SetNotifyEvent;
  end;
   
  {
    Para atribuir um valor a um evento,
    use o prefixo "@" no procedimento alvo.
    Por exemplo, o procedimento "SomeEvent"
    poderia ser atribuído à "NotifyEvent" assim:
       
      NotifyEvent := @SomeEvent;
       
    e disparado assim:
       
      NotifyEvent(Self);
   
    "Self" é uma variável especial dentro de uma classe.
    Ela contém a identidade de um certo objeto.
    Todos os objetos possuem identidades diferentes. 
   
    Lembre que "evento" e "procedimento" devem
    possuir a mesma assinatura para que uma
    atribuição seja possível.
  }
</code></pre></div></div>

<h2 id="a-aplicação-padrão-do-lazarus">A aplicação padrão do Lazarus</h2>

<h3 id="diretivas-de-compilação">Diretivas de compilação</h3>

<p>Em geral, você não precisa se preocupar com diretivas. Mas é importante saber que elas são palavras-chave entre chaves iniciadas por um cifrão: <strong>{$DIRETIVA}</strong>. Diretivas de compilação são instruções ao compilador (ao Free Pascal), não instruções do programa (neste contexto, o código do projeto piloto). Elas podem incluir elementos, assim como mudar o significado de elementos sintáticos de um dialeto. As seguintes diretivas especificam o dialeto utilizado neste guia. Ele corresponde ao dialeto da aplicação padrão do Lazarus (a interface de desenvolvimento):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // diretivas incluídas por padrão nos módulos criados pelo Lazarus
 {$MODE ObjFPC}   // habilita a sintaxe de orientação ao objeto
 {$H+}            // Torna o tipo String um apelido para o tipo AnsiString
 
  // diretivas não incluídas por padrão nos arquivos,
  // mas passadas por padrão pelo Lazarus ao compilador
 {$COPERATORS ON} // habilita os operadores +=, -=, *= e /=
 {$GOTO ON}       // habilita as palavras-chave label e goto
 {$INLINE ON}     // habilita a declaração de procedimentos inline
</code></pre></div></div>

<h3 id="o-formato-dos-arquivos">O formato dos arquivos</h3>

<p>Diversos elementos da sintaxe básica podem ser identificados na aplicação padrão do Lazarus. Para abrir o arquivo de projeto da aplicação; clique sobre a janela Editor de Código, pressione CTRL+O e selecione o arquivo “projetopiloto.lpr”. Esse arquivo possui a seguinte estrutura:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> program ProjetoPiloto; // projetopiloto.lpr                 
 
  {$mode objfpc}{$H+} // diretivas de compilação 
 
 uses   // início do bloco de uso de unidades
    Interfaces, // uma interface específica para o sistema torna-se disponível 
    Forms,      // torna a classe TForm visível
    Unit1       // torna a variável Form1 visível  
 ;             // final do bloco de uso de unidades
 
  {$R *.res} // inclui recursos auxiliares no arquivo executável
 
 begin // início do bloco de execução central do programa
 
    // produz um erro se uma janela for criada sem recursos
    RequireDerivedFormResource:=true;  
     
    // inicializa a interface gráfica, dentre outras coisas...
    Application.Initialize;                
     
    // cria o componente TForm1 atribuindo o resultado à variável Form1
    Application.CreateForm(TForm1, Form1); 
     
    // carrega a janela principal (Form1) e o laço (loop) de eventos
    Application.Run;                       
 end. // final do bloco de execução central do programa 
</code></pre></div></div>

<p>Para os objetivos do presente guia, o arquivo de projeto será gerenciado automaticamente pelo Lazarus e apenas o arquivo contendo a janela principal será editado. Abra o arquivo “Forms.Main.pas” na janela do editor de código e confira sua estrutura:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> unit Forms.Main;    // título e início da unidade
 
 {$mode objfpc}{$H+} // diretivas de compilação
 
 interface           // bloco público da unidade
 
 uses          // bloco de uso com sete unidades
    Classes,    // classes e métodos para criação de objetos recorrentes 
    SysUtils,   // classes e métodos para conversões entre tipos básicos 
    FileUtil,   // classes e métodos para o manuseio de arquivos
    Forms,      // classes e métodos para a criação de janelas
    Controls,   // classes e métodos para a criação de controles visíveis
    Graphics,   // classes e métodos para o manuseio de imagens
    Dialogs;    // classes e métodos para a criação de caixas de mensagens
 
 type          // bloco de tipo
 
    // declara uma nova classe de janela (que você pode customizar)
    TForm1 = class(TForm) 
    private    // campo privado da classe
 
    public     // campo público da classe
 
    end;       // final da declaração da classe
 
 var          // bloco de declaração de variáveis
 
    // declara Form1 como um objeto da classe de janelas TForm1
    Form1: TForm1; 
 
 implementation // campo privado da unidade
 
  // inclui recursos auxiliares no arquivo executável da aplicação
  {$R *.lfm} 
 
 end. // final da unidade
</code></pre></div></div>

<p>Como customizar a classe TForm1 e adaptá-la às nossas necessidades?</p>

<h2 id="exemplos">Exemplos</h2>

<p>Os exemplos a seguir ilustram como resolver tarefas básicas relacionadas ao registro do comportamento e apresentação de eventos ambientais. Procedimentos e eventos simples serão implementados com o auxílio de recursos visuais e atalhos de teclado da interface.</p>

<h3 id="exemplo-1-registro-tabulado-de-frequência-e-tempo">Exemplo 1. Registro tabulado de frequência e tempo</h3>

<p>Alguns computadores pessoais permitem registrar eventos na escala de nanosegundos. Mas a escala de tempo do comportamento ao olho nu é bem mais lenta, e registros muito bem detalhados podem ser obtidos com granularidade máxima na escala de milissegundos. A granularidade do sistema de registro é sua frequência de amostragem. Ela ocorrer, ou melhor, deve ocorrer de forma monotônica, isto é, não devem haver saltos irregulares de tempo no gerador das unidades de tempo: o relógio do computador.</p>

<p>Para obter um registro em milissegundos, implemente a unidade “Timestamps”. Crie uma nova unidade por meio do menu superior “Arquivo-&gt;Nova Unidade”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> unit Timestamps;
 
  {$mode objfpc}{$H+}
 
  interface
 
  // essa função pode ser chamada muitas vezes
  // por isso a directiva "inline" é declarada ao final
 function Miliseconds(FirstTickCount : Cardinal) : string; inline; 
 
  implementation
 
 uses SysUtils; 
 
  // um registro cumulativo de tempo deve tomar 
  // o primeiro registro como referência (FirstTickCount)
 
  // o tipo cardinal só admite valores
  // inteiros maiores ou iguais a zero 
 function Miliseconds(FirstTickCount : Cardinal) : string;
  begin
    // a função GeTickCount64 retorna um tempo monotônico em milisegundos
    // a função IntToStr converte o valor para texto
    Result := IntToStr(GetTickCount64 - FirstTickCount);  
 end; 
 
 end.
</code></pre></div></div>

<p>Registros de texto tabulados além de permitirem a inspeção visual por meio de editores de texto simples, também permitem a automação da leitura dos dados para posterior tratamento e análise. Registros tabulados também são simples de serem implementados com o Free Pascal. Crie uma nova unidade e implemente um registrador tabulado da seguinte maneira:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> unit TabDelimitedReport;
 
  {$mode objfpc}{$H+}
 
  interface
 
  type
 
    { TTabDelimitedReport }
 
    TTabDelimitedReport = class
    private
      FFilename : string;
      FTextFile : TextFile;
      procedure SetFilename(AFilename: string);
    public
      procedure CloseFile;
      procedure NextFile;
      procedure WriteRow(Cols : array of string);
      property Filename : string read FFilename write SetFilename;
    end;
 
  var
    Report : TTabDelimitedReport;       // variável pública
 
  implementation
 
 uses SysUtils, LazFileUtils; // torna visível funções para o manuseio de arquivos
 
 procedure TTabDelimitedReport.WriteRow(Cols: array of string);
  const
    TAB = #9;
  var
    i : Integer;
    LastColumn : Integer;
  begin
    LastColumn := High(Cols);
    for i := 0 to LastColumn do          // percorre todos os itens
      if i &lt; LastColumn then             // se antes do último item
        Write(FTextFile, Cols[i]+TAB)    // escreve item e TAB        
      else               // se último escreve item e final de linha
        WriteLn(FTextFile, Cols[i]);  
    Flush(FTextFile);                    // salva as mudanças no disco rígido 
 end;
 
 procedure TTabDelimitedReport.SetFilename(AFilename: string);
  var
    LFilePath, LExtension, LBasename: string;
    i : Integer;
  begin
                     // retorna o caminho raiz do nome de arquivo
    LFilePath := ExtractFilePath(AFilename);
 
                     // retorna apenas o nome base do arquivo
                     // sem extenção e sem caminho
    LBasename := ExtractFileNameOnly(AFilename);
 
                       // retorna a extenção do nome do arquivo
    LExtension := ExtractFileExt(AFilename);
 
                       // caso a extenção seja vazia ou .exe
                       // a extenção torna-se '.txt' 
    case LExtension of
    '', '.exe' : LExtension:='.txt';
    end;
 
                        // nunca subscreva um arquivo já existente
                        // se o arquivo existir, incremente seu nome
    i := 0;
    while FileExists(AFilename) do
      begin
        Inc(i);
        AFilename := LFilePath+LBasename+'_data_'+Format('%.3d', [i])+LExtension;
      end;
 
                         // atribui um nome ao arquivo de texto
    AssignFile(FTextFile, AFilename);
    Rewrite(FTextFile);    // abre o arquivo de texto para escrita
    FFilename:=AFilename;  // salva o nome do arquivo para uso posterior
 end;
 
 procedure TTabDelimitedReport.NextFile;
  begin
    SetFilename(FFilename);             // abre um novo arquivo
 end;
 
 procedure TTabDelimitedReport.CloseFile;
  begin
    System.Close(FTextFile);            // fecha o arquivo de texto
 end;
 
 initialization // antes de executar o programa, crie (a memória do) objeto
    Report := TTabDelimitedReport.Create;
 
 finalization   // após finalizar o programa, libere (a memória do) objeto
    Report.Free;
 
 end.
</code></pre></div></div>

<p>Em seguida, selecione o arquivo “Forms.Main.pas” (correspondente a janela principal) e use as unidades “Timestamps” e “TabDelimitedReport” na cláusula privada de uso de unidades:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> implementation  // campo privado da unidade
 
  {$R *.lfm}
 
  // torna visível a variável do relatório (Report)
  // e a função Miliseconds
 uses TabDelimitedReport, Timestamps; 
 
 end.   
</code></pre></div></div>

<p>Para criar um arquivo de texto e o cabeçalho (“Tempo Categoria Evento”), utilize o evento de criação da janela principal:</p>

<ul>
  <li>Selecione o arquivo “Forms.Mains.pas”.</li>
  <li>Selecione a janela principal (Aperte F12).</li>
  <li>Clique duas vezes sobre o fundo da janela principal.</li>
  <li>O procedimento padrão “OnCreate” será declarado automaticamente.</li>
  <li>implemente o procedimento da seguinte maneira:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure TForm1.FormCreate(Sender: TObject);
begin
  // use a variável pública da unidade TabDelimitedReport
  // a propriedade Filename permite criar e inicializar
  // o arquivo de texto do relatório
  Report.Filename := Application.ExeName;

  // Application refere-se à variável
  // da unidade Forms. A propriedade ExeName
  // retorna o caminho completo do arquivo executável da aplicação
   
  // escreve o cabeçalho do programa
  Report.WriteRow(['Tempo', 'Categoria', 'Evento']);
end; 
</code></pre></div></div>
<p>Ao final do programa, é necessário fechar o arquivo de texto. Para isso usaremos o evento de finalização da aplicação:</p>

<ul>
  <li>Selecione o arquivo “Forms.Main.pas”.</li>
  <li>Alterne para a janela principal (Aperte F12).</li>
  <li>Clique sobre o fundo da janela principal.</li>
  <li>Selecione a janela Inspetor de Objetos (Aperte F11).</li>
  <li>Selecione a aba Eventos.</li>
  <li>Clique duas vezes sobre o campo em branco do evento “OnDestroy”.</li>
  <li>O procedimento será declarado automaticamente, implemente-o da seguinte maneira:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure TForm1.FormDestroy(Sender: TObject);
begin
// fecha o arquivo de texto
Report.CloseFile;
end;
</code></pre></div>    </div>
  </li>
</ul>

<p>Por meio de diversas chamadas ao procedimento “WriteRow” do objeto “Report”, um relatório em formato de texto simples com a seguinte estrutura é esperado:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Tempo   Categoria         Evento
 0000   estimulo     S1
 2000   resposta     R1
 2500   estimulo     C1
 5050   estimulo     S1
 5500   resposta     R2
 6000   resposta     R2
 6100   resposta     R2
 7000   resposta     R2
 9000   resposta     R1
 9500   estimulo     C1
</code></pre></div></div>

<p>Um relatório deve conter todas as informações de interesse. Nesse caso, duas respostas (R1 e R2) e dois estímulos (S1 e C1) devem ser registrados pelo programa. O programa está pronto para rastreá-los. Mas como detectar a ocorrência desses eventos?</p>

<h3 id="exemplo-2-rastreamento-de-estímulos-e-respostas">Exemplo 2. Rastreamento de estímulos e respostas</h3>

<p>Rastreadores de função e forma são requisitos para análises comportamentais que almejam alto poder preditivo. Por ser multideterminado, o comportamento demanda a análise conjunta de múltiplas fontes de dados. Na presente ocasião, por questões didáticas, a ênfase será na forma. Ao interagir com uma interface gráfica, dois tipos de eventos serão de especial interesse: respostas ao teclado e respostas ao mouse. Adicionalmente, estímulos, como mudanças na visibilidade de componentes da interface, serão rastreados por meio de um evento customizado. Crie uma nova unidade e implemente o evento da seguinte maneira:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> unit Behavior.Events;
 
  {$mode objfpc}{$H+}
 
  interface
 
  uses
    Classes;   // torna visível a classe TObject
 
 type         // bloco de declaração de tipo
    // o procedimento recebe o nome de uma categoria, um evento
    // e o objeto que enviou a mensagem
    TBehavioralEvent = procedure(Sender: TObject; const Category: string;
   const Event:string) of object;
 
    // define as possíveis categorias como constantes simples
  const
    BehavioralEvent = 'resposta';
    EnviromentEvent = 'estimulo';
    SystemEvent = 'virtual';
 
  implementation
 
    // toda unidade precisa de um bloco de implementação
    // ainda que vazia
 
 end.
</code></pre></div></div>

<p>A unidade com o evento comportamental deve ser usada em duas outras unidades. Primeiramente, a classe de estímulos “TStimulus” deve criada a partir da classe “TImage”. A classe “TImage” possui eventos de mouse e métodos para a apresentação de figuras. Crie uma nova unidade e implemente a classe “TStimulus” da seguinte maneira:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unit ExtCtrls.Stimulus;
 
{$mode objfpc}{$H+}
 
interface
 
uses
  ExtCtrls,        // torna visível a unidade TImage
  Behavior.Events; // torna visível o evento TBehavioralEvent
 
type
  
  { TStimulus }
 
  TStimulus = class(TImage) // cria a classe TStimulus a partir da casse TImage
  private
    FOnVisibilityChange: TBehavioralEvent;
    procedure SetOnVisibilityChange(AValue: TBehavioralEvent);
  protected
    // a directiva override permite customizar o procedimento
    // SetVisible da classe Timage este procedimento é usado
    // para detectar a mudança de visibilidade dos estímulos
    procedure SetVisible(Value: Boolean); override;
  public
    // para declarar o evento comportamental
    // escreva "property OnVisibilityChange : TBehavioralEvent;"
    // e em seguida aperte CTRL+SHIFT+C
    // a propriedade será declarada automaticamente
  property OnVisibilityChange : TBehavioralEvent read FOnVisibilityChange write
 SetOnVisibilityChange;
  end;
 
implementation
 
{ TStimulus }
 
procedure TStimulus.SetOnVisibilityChange(AValue: TBehavioralEvent);
begin
  if FOnVisibilityChange=AValue then Exit;
  FOnVisibilityChange:=AValue;
end;
 
procedure TStimulus.SetVisible(Value: Boolean);
begin // implementação de eventos de estímulo 
  // primeiramente é necessário 
  // chamar o procedimento SetVisible de TImage
  // isso é possível por meio do prefixo inherited
  inherited SetVisible(Value);
  // se um valor foi atribuido à propriedade então
  if Assigned(OnVisibilityChange) then   
    if Value then // se visível
      // dispara o evento da propriedade como "Show"
      OnVisibilityChange(Self, EnviromentEvent, 'Show') 
    else          // se invisível
      // dispara o evento da propriedade como "Hide"
      OnVisibilityChange(Self, EnviromentEvent, 'Hide');
 end;
end.
</code></pre></div></div>

<p>Em seguida os estímulos devem ser criados, configurados e apresentados na janela principal da aplicação. Os eventos associados à janela também devem ser implementados e configurados. Implemente-os da seguinte maneira:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  unit Forms.Main;
     
  {$mode objfpc}{$H+}
     
  interface
     
  uses
    Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,
    ExtCtrls.Stimulus; // torna visível a classe TStimulus
     
  type
     
    { TForm1 }
     
    TForm1 = class(TForm)
      // declara um estímulo antecedente
      StimulusAntecedent : TStimulus;
     
      // declara um estímulo consequente 
      StimulusConsequent : TStimulus; 
     
      // declara o procedimento dos eventos de clique da janela
      procedure ComponentClick(Sender: TObject);  
     
      // declara o procedimento dos eventos de teclado da janela
      procedure ComponentKeyPress(Sender: TObject; var Key: char);
     
      // declara o procedimento de criação da janela
      procedure FormCreate(Sender: TObject);
      
      // declara o procedimento de destruição da janela
      procedure FormDestroy(Sender: TObject);
      
      // declara o procedimento de registro de respostas e estímulos
      procedure RecordBehavior(Sender: TObject; const Category:string;
        const EventSufix: string); inline;
    private
      // declara uma variável privada para o valor de início do registro
      FFirstTickcount : Cardinal;
     
      // declara um método de ajuda para a criação e configuração dos
      // estímulos
      procedure CreateStimulus(out AStimulus : TStimulus; AColor : TColor;
        ASize : integer = 300; ALeft : integer = 0; ATop: integer = 0);
    public
     
    end;
     
  var
    Form1: TForm1;
     
  implementation
     
  // unidades usadas apenas na implementação
  uses TabDelimitedReport, Timestamps, Behavior.Events; 
     
  {$R *.lfm}
     
  { TForm1 }
     
     
  // o que acontece quando a janela principal for criada?
 procedure TForm1.FormCreate(Sender: TObject);
  begin
  // cria o estímulo antecedente com cor preta
    CreateStimulus(StimulusAntecedent, clBlack,150,0,0);
     
    // cria o estímulo consequente com cor azul
    CreateStimulus(StimulusConsequent, clBlue,100,200,0);
     
    // os estímulos são rastreados pelos seus
    // respectivos nomes
    StimulusAntecedent.Name:='Preto';
    StimulusConsequent.Name:='Azul';
     
    // cabeçalho do relatório
    Report.Filename := Application.ExeName;
    Report.WriteRow(['Tempo', 'Categoria', 'Evento']);
     
    // valor de início do registro independente da hora local
    FFirstTickcount := GetTickCount64;
     
  // início de acordo com a data e hora local
    RecordBehavior(Sender, SystemEvent, 'inicio:'+DateTimeToStr(Now));
     
    // mostra o estímulo antecedente
    StimulusAntecedent.Show;
  end;
     
  // o que acontece quando a janela principal for destruida?
 procedure TForm1.FormDestroy(Sender: TObject);
  begin
    // registra o final de acordo com a hora local
    RecordBehavior(Sender, SystemEvent, 'final:'+DateTimeToStr(Now));
     
    // finaliza o relatório
    Report.CloseFile;
  end;
     
 procedure TForm1.RecordBehavior(Sender: TObject; const Category: string;
    const EventSufix: string);
  var
    SenderName: string;
  begin
    // o rastreamento ocorre por meio
    // do nome dos objetos
    if Sender is TComponent then
      SenderName := TComponent(Sender).Name
    else
      SenderName := Sender.ClassName;
     
  // registra uma linha no relatório
    Report.WriteRow([
      Miliseconds(FFirstTickcount),
      Category,
      SenderName+#32+EventSufix
    ]);
  end;
     
 procedure TForm1.CreateStimulus(out AStimulus: TStimulus; AColor: TColor;
    ASize: integer; ALeft: integer; ATop: integer);
  begin
    // note que AStimulus é um argumento de saída (out)
     
    // cria o estímulo na janela principal (self) 
    AStimulus := TStimulus.Create(Self);
     
    // define o tamanho do estímulo
    // Left e Top possuem origem no canto superior esquerdo do monitor:
    // Left pixel horizontal
    // Top pixel vertical
    AStimulus.SetBounds(ALeft, ATop, ASize, ASize);
     
    // define o tamanho da figura do estímulo
    AStimulus.Picture.Bitmap.SetSize(ASize, ASize);
     
    // define a cor da figura do estímulo
    AStimulus.Picture.Bitmap.Canvas.Brush.Color := AColor;
     
    // desenha um retângulo preenchido na figura com a cor definida
    AStimulus.Picture.Bitmap.Canvas.Rectangle(0,0, ASize, ASize);
     
  {****************** MUITO IMPORTANTE ********************}
     
    // não esqueça de definir aonde o estímulo será desenhado
    // isto é possível por meio da propriedade Parent
    // aqui definimos a janela principal (Self) como o
    // responsável por desenhar o estímulo
     
                                AStimulus.Parent := Self;
     
  {********************************************************}
     
    // define a visibilidade inicial do estímulo
    AStimulus.Hide;
     
    // atribui um valor às propriedades dos estímulos
    // o operador @ deve ser usado na frente do
    // procedimento correspondente ao evento
    // da propriedade
    // para relembrar a assinatura do evento
    // segure CTRL e clique com o botão esquerdo na
    // propriedade
    AStimulus.OnVisibilityChange:=@RecordBehavior;
    AStimulus.OnClick:=@ComponentClick;
  
    // também seria possível carregar uma figura 
    // por meio do nome do arquivo da figura
    // AStimulus.Picture.LoadFromFile(AFilename);
    // AStimulus.Stretch := True;
  end;
     
  // o que acontece quando um componente é clicado?
  procedure TForm1.ComponentClick(Sender: TObject);
  begin
    // registra o comportamento de clique
    RecordBehavior(Sender, BehavioralEvent, 'Click');
      
    // altera a visibilidade dos estímulos
    // de acordo com os estímulos clicados
    if Sender = StimulusAntecedent then
      begin
        StimulusAntecedent.Hide;
        StimulusConsequent.Show;
      end;
    if Sender = StimulusConsequent then
      begin
        StimulusConsequent.Hide;
        StimulusAntecedent.Show;
      end;
  end;
     
  // o que acontece quando uma tecla é pressionada
  // tendo um componente em foco?
  procedure TForm1.ComponentKeyPress(Sender: TObject; var Key: char);
  const
    SpaceKey = #32;
    DeleteKey = #127;
  var
    Event : string = '';
  begin
    case Key of
      SpaceKey : Event := '&lt;32&gt;';
      DeleteKey: Event := '&lt;127&gt;';
      #0..#31  : Event := '&lt;NA&gt;';
    end;
    RecordBehavior(Sender, BehavioralEvent, Event);
  end;
     
  end.
</code></pre></div></div>

<p>Por fim, configure os eventos de clique (“OnClick” deve receber o valor de “ComponentClick”) e teclado (“OnKeyPress” deve receber o valor de “ComponentKeyPress”) da janela principal:</p>

<ul>
  <li>Selecione o arquivo “Forms.Main.pas”.</li>
  <li>Alterne para a janela principal (Aperte F12).</li>
  <li>Clique sobre o fundo da janela principal.</li>
  <li>Selecione a janela Inspetor de Objetos (Aperte F11).</li>
  <li>Selecione a aba Eventos.</li>
  <li>No evento “OnClick”, selecione o evento “ComponentClick” na lista.</li>
  <li>No evento “OnKeyPress”, selecione o evento “ComponentKeyPress” na lista.</li>
  <li>Execute a aplicação e confira os resultados! O código fonte dos exemplos apresentados e de outros exemplos podem ser conferidos no seguinte repositório:</li>
  <li><a href="https://github.com/cpicanco/free-pascal-prototypes">https://github.com/cpicanco/free-pascal-prototypes</a></li>
</ul>

<h2 id="referências">Referências</h2>

<div class="self-font" style="text-indent: -4em;padding-left: 4em;padding-top: 1em;">
  <div class="csl-entry">Apple Computer Inc (Org.). (1985). <i>Inside Macintosh</i> (1º ed, Vol. 1). Cupertino, CA: Addison-Wesley.
</div>
</div>

<div class="self-font" style="text-indent: -4em;padding-left: 4em;padding-top: 1em;">
  <div class="csl-entry">Borland International Inc. (1984/1983). <i>Turbo Pascal Reference Manual</i> (2º ed). Scotts Valley, CA.
</div>
</div>

<div class="self-font" style="text-indent: -4em;padding-left: 4em;padding-top: 1em;">
  <div class="csl-entry">Jensen, K., &amp; Wirth, N. (1974). <i>PASCAL User Manual and Report</i> (Vol. 18). Berlin, Heidelberg: Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-662-21554-8
</div>
</div>

<div class="self-font" style="text-indent: -4em;padding-left: 4em;padding-top: 1em;">
  <div class="csl-entry">Klämpfl, F., Codère, C. E., Mantione, D., Maebe, J., Van Canneyt, M., Vreman, P., … van de Voort, M. (2018). Free Pascal Compiler (Versão v3.0.4-2) [Multi-platforma]. Recuperado de http://www.freepascal.org/
</div>
</div>

<div class="self-font" style="text-indent: -4em;padding-left: 4em;padding-top: 1em;">
  <div class="csl-entry">Lazarus IDE (Versão v1.8.2) [Programa de computador]. (2018). Recuperado de http://www.lazarus-ide.org
</div>
</div>

<div class="self-font" style="text-indent: -4em;padding-left: 4em;padding-top: 1em;">
  <div class="csl-entry">Severance, C. (2012). The Art of Teaching Computer Science: Niklaus Wirth. <i>IEEE Computer Society</i>, <i>45</i>(7), 8–10.
</div>
</div>


          </div>  
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <p>_</p>
            <!-- Author-Date -->
          
          
            <span class="meta margin-top">&#32;<a href='http://portfolio.rafael.picanco.nom.br/pt-br/projects.html'>Rafael Picanço</a>,&#32;
            15
            &#32;de&#32;
            
            Agosto
              
            &#32;de&#32;
            2017.
            </span>
           
            <hr>
            <!-- Social Buttons -->
            <ul class="list-inline">
            
              <li>
                <a id="tw-root" href="https://twitter.com/share" class="twitter-share-button" data-url="https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html" data-text="Object Pascal e Análise do Comportamento, from Rafael Picanço's blog" data-counturl="https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html" data-count="horizontal" data-via="crpicanco" title="Tweet">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>

              <li id="fb-root">
                <a id="fb-fa" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html', 'facebook-share','width=580,height=296');return false;" title="Compartilhe no Facebook">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
                <a class="fb-like" data-href="https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html" data-layout="button_count" data-action="like" data-share="true" data-text="Object Pascal e Análise do Comportamento, blog do Rafael Picanço" data-counturl="https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html" data-proofer-ignore></a>
              </li>
            </ul>
            <hr>
            <div class="text-center">         
            
              <a class="btn btn-default btn-block" href="/pt-br/">LEIA MAIS</a>
            
            </div>
          </div>
        </div>          
      </div>
    </article>
    
    <hr>

    <div id="disqus_thread" class="container"></div>

    <!-- Footer -->
    <footer id="about">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <ul class="list-inline text-center">
              <li>
                <a href="https://twitter.com/crpicanco">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://soundcloud.com/carlitusbatera">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-soundcloud fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/cpicanco">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
            </ul>
            <p class="text-muted text-center">
            
              &copy; Carlos Rafael Fernandes Picanço, 2015-2019.<br>
              Hospedado pelo <a href="https://github.com/cpicanco/blog/">GitHub Pages</a>.<br>
              Construido com o <a href="https://getbootstrap.com/">Bootstrap</a> e o <a href="https://jekyllrb.com/">Jekyll</a>.<br>
            
            </p>
          </div>
        </div>
      </div>
    </footer>


    <!-- JQuery may conflict with Bootstrap, they said -->        
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
        <script>
          if (typeof jQuery === 'undefined') {
            document.write(unescape('%3Cscript%20src%3D%22/js/jquery.min.js%22%3E%3C/script%3E'));
          };
        </script>
      <!-- Bootstrap core JavaScript
        ================================================== -->
        <!-- Placed at the end of the document so the pages load faster 
        http://encosia.com/3-reasons-why-you-should-let-google-host-jquery-for-you/
        http://stackoverflow.com/questions/26192897/should-i-use-bootstrap-from-cdn-or-make-a-copy-on-my-server
      -->
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
        <script>
          if (typeof($.fn.modal) === 'undefined') {
            document.write(unescape('%3Cscript%20src%3D%22/js/bootstrap.min.js%22%3E%3C/script%3E'));
          };
        </script>

        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <script src="/js/ie10-viewport-bug-workaround.min.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-59877002-2');
        </script>


        <!-- Google Knowledge Graph -->
    
    
        <script type="application/ld+json">
        {
          "@context": "http://schema.org",
          "@type": "Article",
          "author": "Rafael Picanço",
          "name": "Object Pascal e Análise do Comportamento",
          "articleSection": "ciência, programação",
          "datePublished": "2017-08-15",
          "headline": "Introdução ao desenvolvimento de interfaces gráficas com Lazarus e Free Pascal",
          
          "image": "https://blog.rafael.picanco.nom.br/media/blog/in-flagellis-clean.png"
          
        }
        </script>
    

    <!-- Lazy load -->
        <!-- Twitter JavaScript
        http://www.paulund.co.uk/lazy-load-social-media
        -->
        <script type="text/javascript">
          var tweetHover = function(e){
            $(e).hover(
              function(){ // mouse enter
                if ($(this).hasClass("share-enabled")) {
                  // do nothing
                } else {
                  if (typeof (twttr) != 'undefined'){ // will load just the entered #tw-root
                    twttr.widgets.load(this);
                    $(this).addClass("share-enabled");
                  } else {  // will load all #tw-root, and it sucks
                    $.getScript('https://platform.twitter.com/widgets.js');
                    $(this).addClass("share-enabled");
                  }
                }
              },
              function(){ // mouse leave

              }
            );           
          };
          $(document).ready(function(){
            tweetHover("#tw-root");
          });
        </script>
        
        <!-- Facebook JavaScript
        https://developers.facebook.com/docs/javascript/howto/jquery/v2.4
        -->
        <script type="text/javascript">
          var facebook_sdk = '//connect.facebook.net/en_US/sdk.js';
          if (document.documentElement.lang = 'pt-BR') {
            facebook_sdk = '//connect.facebook.net/pt_BR/sdk.js';
          };
          
          var facebookHover = function(e){
            $(e).hover(
              function(){ // mouse enter
                if ($(this).hasClass("share-enabled")) {
                  // do nothing
                } else {
                  if (typeof (FB) != 'undefined') { // will load just the entered #fb-root
                    FB.XFBML.parse(this); 
                    $(this).addClass("share-enabled");
                    $(this).find("#fb-fa").remove();
                  } else { // will load all #fb-root, and it sucks too
                    $.getScript(facebook_sdk, function(){
                      FB.init({
                        appId   : '179917338701622',
                        xfbml   : true,
                        version : 'v2.4'
                      });
                    });
                    $(this).addClass("share-enabled");
                    $(document).find("[id=fb-fa]").each(function(){$(this).remove()});
                  }
                }
              },
              function(){ // mouse leave
                //
              }
            );
          };
          $(document).ready(function(){
            facebookHover("#fb-root");
          });
        </script>

    <!-- Highlight.js -->
  <script src="/js/highlight-pack.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
        <!-- Disqus scripts -->
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES * * */
      var dlanguage = 'en';
      if (document.documentElement.lang = 'pt-BR') {
        dlanguage = 'pt';
      };
      var disqus_shortname = 'inflagellis';
      var disqus_url = 'https://blog.rafael.picanco.nom.br/2017/08/15/object-pascal.html';
      var disqus_identifier = '/2017/08/15/object-pascal';
      var disqus_config = function () {
                            this.language = dlanguage;
                          };

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();

      /* * * Disqus Reset Function * * */
      function resetDisqus(newIdentifier, newUrl, newTitle, newLanguage) {
        DISQUS.reset({
          reload: true,
          config: function () {
            this.page.identifier = newIdentifier;
            this.page.url = newUrl;
            this.page.title = newTitle;
            this.language = newLanguage;
          }
        });
      };
    </script>

    <!-- Custom Theme JavaScript -->
    <script src="/js/clean-blog.min.js"></script> 
  </body>
</html>
